package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model" // Adjust import path if needed
	"log"
	"os"
	"time"

	_ "github.com/lib/pq" // PostgreSQL driver
	amqp091 "github.com/rabbitmq/amqp091-go"
)

// Add this AccountResolver interface definition
type AccountResolver interface {
	IsFollowing(ctx context.Context, obj *model.Account) (*bool, error)
}

// Ensure this line exists to connect the interface to the main Resolver struct
func (r *Resolver) Account() AccountResolver { return &accountResolver{r} }

// Add this struct definition
type accountResolver struct{ *Resolver }

// IsFollowing is the resolver for the isFollowing field.
func (r *accountResolver) IsFollowing(ctx context.Context, obj *model.Account) (*bool, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		f := false
		return &f, nil
	}
	targetUserID := obj.AccountID
	if currentUserID == targetUserID {
		f := false
		return &f, nil
	}
	db, err := getDB()
	if err != nil {
		log.Printf("IsFollowing resolver DB Error: %v", err)
		f := false
		return &f, nil
	}
	defer db.Close()
	var exists bool
	queryCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()
	query := `SELECT EXISTS (SELECT 1 FROM follows WHERE follower_user_id = $1 AND followed_user_id = $2)`
	err = db.QueryRowContext(queryCtx, query, currentUserID, targetUserID).Scan(&exists)
	if err != nil {
		log.Printf("IsFollowing resolver DB query error (%s -> %s): %v", currentUserID, targetUserID, err)
		f := false
		return &f, nil
	}
	return &exists, nil
}

// --- Mutation Resolvers ---

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("Register DB Error: %v", err)
		return nil, fmt.Errorf("internal error connecting to DB")
	}
	defer db.Close()

	var accountID string
	var createdAt time.Time
	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	defer cancelInsert()
	err = db.QueryRowContext(insertCtx, `
		INSERT INTO accounts (email, password, first_name, last_name, address, phone, age, gender, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
		RETURNING id, created_at
	`, input.Email, input.Password, input.FirstName, input.LastName, input.Address, input.Phone, input.Age, input.Gender).Scan(&accountID, &createdAt)

	if err != nil {
		log.Printf("Register DB Error inserting account: %v", err)
		return nil, fmt.Errorf("internal error registering account")
	}

	// Publish a message to RabbitMQ
	go func() {
		rabbitmqURL := os.Getenv("RABBITMQ_URL")
		if rabbitmqURL == "" {
			log.Println("Register: RABBITMQ_URL not set, skipping message publish.")
			return
		}
		conn, err := amqp091.Dial(rabbitmqURL)
		if err != nil {
			log.Printf("Register: failed to connect to RabbitMQ: %v", err)
			return
		}
		defer conn.Close()
		ch, err := conn.Channel()
		if err != nil {
			log.Printf("Register: failed to open a channel: %v", err)
			return
		}
		defer ch.Close()
		q, err := ch.QueueDeclare("user_registered", true, false, false, false, nil)
		if err != nil {
			log.Printf("Register: failed to declare a queue: %v", err)
			return
		}
		body := fmt.Sprintf(`{"accountId":"%s","email":"%s"}`, accountID, input.Email)
		pubCtx, pubCancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer pubCancel()
		err = ch.PublishWithContext(pubCtx, "", q.Name, false, false, amqp091.Publishing{ContentType: "application/json", Body: []byte(body), Timestamp: time.Now()})
		if err != nil {
			log.Printf("Register: failed to publish user_registered message: %v", err)
		} else {
			log.Printf("Register: Published user_registered message for %s", accountID)
		}
	}()

	return &model.Account{AccountID: accountID, Email: input.Email, FirstName: input.FirstName, LastName: input.LastName, Address: input.Address, Phone: input.Phone, Age: input.Age, Gender: input.Gender, CreatedAt: createdAt.Format(time.RFC3339)}, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, userIdToFollow string) (*model.Account, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("FollowUser Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}
	if currentUserID == userIdToFollow {
		return nil, fmt.Errorf("cannot follow yourself")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("FollowUser DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var followedAccount model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, userIdToFollow).Scan(&followedAccount.AccountID, &followedAccount.Email, &followedAccount.FirstName, &followedAccount.LastName, &followedAccount.Address, &followedAccount.Phone, &followedAccount.Age, &followedAccount.Gender, &createdAt, &updatedAt)
	cancelQuery()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user to follow not found")
		}
		log.Printf("FollowUser DB Error querying followed user %s: %v", userIdToFollow, err)
		return nil, fmt.Errorf("internal server error")
	}
	followedAccount.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
		followedAccount.UpdatedAt = &formattedUpdatedAt
	} else {
		followedAccount.UpdatedAt = nil
	}

	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	result, err := db.ExecContext(insertCtx, `INSERT INTO follows (follower_user_id, followed_user_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`, currentUserID, userIdToFollow)
	cancelInsert()
	if err != nil {
		log.Printf("FollowUser DB Error inserting follow (%s -> %s): %v", currentUserID, userIdToFollow, err)
		return nil, fmt.Errorf("failed to follow user")
	}

	rowsAffected, _ := result.RowsAffected()
	log.Printf("User %s follow action for user %s (Rows affected: %d)", currentUserID, userIdToFollow, rowsAffected)

	if rowsAffected > 0 {
		log.Printf("New follow detected (%s -> %s), creating notification...", currentUserID, userIdToFollow)
		go func(recipientID string, triggerID string) {
			notifCtx, notifCancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer notifCancel()
			dbNotif, errDb := getDB()
			if errDb != nil {
				log.Printf("FollowUser Notification Goroutine DB Error: %v", errDb)
				return
			}
			defer dbNotif.Close()
			_, errNotif := dbNotif.ExecContext(notifCtx, `INSERT INTO notifications (recipient_user_id, triggering_user_id, notification_type, entity_id, is_read, created_at) VALUES ($1, $2, $3, $4, $5, NOW())`, recipientID, triggerID, "new_follower", triggerID, false)
			if errNotif != nil {
				log.Printf("FollowUser: Failed to insert 'new_follower' notification for recipient %s: %v", recipientID, errNotif)
			} else {
				log.Printf("FollowUser: Inserted 'new_follower' notification for %s triggered by %s", recipientID, triggerID)
			}
		}(userIdToFollow, currentUserID)
	} else {
		log.Printf("User %s already follows %s or conflict occurred, no notification needed.", currentUserID, userIdToFollow)
	}

	return &followedAccount, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, userIdToUnfollow string) (*model.Account, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("UnfollowUser Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("UnfollowUser DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var unfollowedAccount model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, userIdToUnfollow).Scan(&unfollowedAccount.AccountID, &unfollowedAccount.Email, &unfollowedAccount.FirstName, &unfollowedAccount.LastName, &unfollowedAccount.Address, &unfollowedAccount.Phone, &unfollowedAccount.Age, &unfollowedAccount.Gender, &createdAt, &updatedAt)
	cancelQuery()
	if err != nil {
		log.Printf("UnfollowUser: Could not fetch unfollowed user %s, proceeding: %v", userIdToUnfollow, err)
		if err != sql.ErrNoRows {
			log.Printf("UnfollowUser DB Error querying user %s: %v", userIdToUnfollow, err)
		}
		unfollowedAccount.AccountID = userIdToUnfollow // Use ID for return even if fetch failed
	} else {
		unfollowedAccount.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			unfollowedAccount.UpdatedAt = &formattedUpdatedAt
		} else {
			unfollowedAccount.UpdatedAt = nil
		}
	}

	deleteCtx, cancelDelete := context.WithTimeout(ctx, 5*time.Second)
	result, err := db.ExecContext(deleteCtx, `DELETE FROM follows WHERE follower_user_id = $1 AND followed_user_id = $2`, currentUserID, userIdToUnfollow)
	cancelDelete()
	if err != nil {
		log.Printf("UnfollowUser DB Error deleting follow (%s -> %s): %v", currentUserID, userIdToUnfollow, err)
		return nil, fmt.Errorf("failed to unfollow user")
	}

	rowsAffected, _ := result.RowsAffected()
	log.Printf("User %s unfollowed user %s (Rows affected: %d)", currentUserID, userIdToUnfollow, rowsAffected)

	return &unfollowedAccount, nil
}

// --- Query Resolvers ---

// GetAccount is the resolver for the getAccount field.
func (r *queryResolver) GetAccount(ctx context.Context, accountID string) (*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("GetAccount DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var account model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelQuery()
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, accountID).Scan(&account.AccountID, &account.Email, &account.FirstName, &account.LastName, &account.Address, &account.Phone, &account.Age, &account.Gender, &createdAt, &updatedAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("account not found")
		} // Return specific error
		log.Printf("GetAccount DB Error querying account %s: %v", accountID, err)
		return nil, fmt.Errorf("internal server error")
	}

	account.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
		account.UpdatedAt = &formattedUpdatedAt
	} else {
		account.UpdatedAt = nil
	}

	// Note: The Account.IsFollowing field is resolved by the accountResolver.IsFollowing method
	return &account, nil
}

// ListAccounts is the resolver for the listAccounts field.
func (r *queryResolver) ListAccounts(ctx context.Context) ([]*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("ListAccounts DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	queryCtx, cancelQuery := context.WithTimeout(ctx, 10*time.Second)
	defer cancelQuery()
	rows, err := db.QueryContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts ORDER BY created_at DESC`)

	if err != nil {
		log.Printf("ListAccounts DB Error querying: %v", err)
		return nil, fmt.Errorf("failed to list accounts")
	}
	defer rows.Close()

	accounts := []*model.Account{}
	for rows.Next() {
		var acc model.Account
		var createdAt time.Time
		var updatedAt sql.NullTime
		err := rows.Scan(&acc.AccountID, &acc.Email, &acc.FirstName, &acc.LastName, &acc.Address, &acc.Phone, &acc.Age, &acc.Gender, &createdAt, &updatedAt)
		if err != nil {
			log.Printf("ListAccounts DB Error scanning row: %v", err)
			continue
		}
		acc.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			acc.UpdatedAt = &formattedUpdatedAt
		} else {
			acc.UpdatedAt = nil
		}
		// Note: The Account.IsFollowing field is resolved by the accountResolver.IsFollowing method for each account if requested in the query
		accounts = append(accounts, &acc)
	}
	if err = rows.Err(); err != nil {
		log.Printf("ListAccounts DB Error iterating rows: %v", err)
		return nil, fmt.Errorf("error reading accounts list")
	}

	return accounts, nil
}
